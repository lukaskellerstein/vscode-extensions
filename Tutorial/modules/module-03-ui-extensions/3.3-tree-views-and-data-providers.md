# 3.3 Tree Views and Data Providers

## Introduction

Tree views are hierarchical UI components that display data in an expandable/collapsible structure. They're the backbone of many VS Code features like the File Explorer, Outline view, and npm Scripts view. Tree views enable users to navigate complex hierarchical data efficiently.

## What Are Tree Views?

Tree views are:
- **Hierarchical displays** of data in a parent-child structure
- **Interactive** with expand/collapse functionality
- **Customizable** with icons, context menus, and inline actions
- **Data-driven** through TreeDataProvider implementations
- **Integrated** into VS Code's sidebar or custom view containers

## TreeDataProvider Interface

The `TreeDataProvider` interface is the core of tree view functionality. It defines how data is structured and retrieved.

### Basic TreeDataProvider

```typescript
import * as vscode from 'vscode';

class BasicTreeDataProvider implements vscode.TreeDataProvider<string> {

    // Get tree item representation
    getTreeItem(element: string): vscode.TreeItem {
        return new vscode.TreeItem(element);
    }

    // Get children of an element
    getChildren(element?: string): Thenable<string[]> {
        if (!element) {
            // Root level
            return Promise.resolve(['Item 1', 'Item 2', 'Item 3']);
        } else {
            // Children of element
            return Promise.resolve([`${element} - Child 1`, `${element} - Child 2`]);
        }
    }
}

export function activate(context: vscode.ExtensionContext) {
    const treeDataProvider = new BasicTreeDataProvider();

    vscode.window.registerTreeDataProvider(
        'myExtension.basicTree',
        treeDataProvider
    );
}
```

### package.json Configuration

```json
{
    "contributes": {
        "views": {
            "explorer": [
                {
                    "id": "myExtension.basicTree",
                    "name": "Basic Tree"
                }
            ]
        }
    }
}
```

## Custom Tree Items

### TreeItem with Icons and States

```typescript
class FileTreeItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly type: 'file' | 'folder'
    ) {
        super(label, collapsibleState);

        // Set icon
        this.iconPath = this.type === 'file'
            ? new vscode.ThemeIcon('file')
            : new vscode.ThemeIcon('folder');

        // Set context value for context menus
        this.contextValue = this.type;

        // Set tooltip
        this.tooltip = `${this.type}: ${this.label}`;

        // Set description (shown on the right)
        this.description = this.type === 'file' ? 'File item' : undefined;
    }
}

class FileTreeDataProvider implements vscode.TreeDataProvider<FileTreeItem> {

    getTreeItem(element: FileTreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: FileTreeItem): Thenable<FileTreeItem[]> {
        if (!element) {
            // Root level
            return Promise.resolve([
                new FileTreeItem('Documents', vscode.TreeItemCollapsibleState.Collapsed, 'folder'),
                new FileTreeItem('Pictures', vscode.TreeItemCollapsibleState.Collapsed, 'folder'),
                new FileTreeItem('readme.txt', vscode.TreeItemCollapsibleState.None, 'file')
            ]);
        } else if (element.type === 'folder') {
            // Children of folder
            return Promise.resolve([
                new FileTreeItem('file1.txt', vscode.TreeItemCollapsibleState.None, 'file'),
                new FileTreeItem('file2.txt', vscode.TreeItemCollapsibleState.None, 'file')
            ]);
        }

        return Promise.resolve([]);
    }
}
```

## Refreshing Tree Views

### Event-Based Refresh

```typescript
class RefreshableTreeDataProvider implements vscode.TreeDataProvider<string> {

    private _onDidChangeTreeData: vscode.EventEmitter<string | undefined | null | void> =
        new vscode.EventEmitter<string | undefined | null | void>();

    readonly onDidChangeTreeData: vscode.Event<string | undefined | null | void> =
        this._onDidChangeTreeData.event;

    // Refresh entire tree
    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    // Refresh specific element
    refreshElement(element: string): void {
        this._onDidChangeTreeData.fire(element);
    }

    getTreeItem(element: string): vscode.TreeItem {
        return new vscode.TreeItem(element);
    }

    getChildren(element?: string): Thenable<string[]> {
        if (!element) {
            return Promise.resolve(['Item 1', 'Item 2', 'Item 3']);
        }
        return Promise.resolve([]);
    }
}

export function activate(context: vscode.ExtensionContext) {
    const treeDataProvider = new RefreshableTreeDataProvider();

    vscode.window.registerTreeDataProvider(
        'myExtension.refreshableTree',
        treeDataProvider
    );

    // Command to refresh tree
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.refreshTree', () => {
            treeDataProvider.refresh();
        })
    );
}
```

## Real-World Example: File System Tree

### Complete File System Tree Implementation

```typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

class FileSystemNode {
    constructor(
        public readonly uri: vscode.Uri,
        public readonly type: 'file' | 'directory'
    ) {}

    get label(): string {
        return path.basename(this.uri.fsPath);
    }
}

class FileSystemTreeDataProvider implements vscode.TreeDataProvider<FileSystemNode> {

    private _onDidChangeTreeData: vscode.EventEmitter<FileSystemNode | undefined | null | void> =
        new vscode.EventEmitter<FileSystemNode | undefined | null | void>();

    readonly onDidChangeTreeData: vscode.Event<FileSystemNode | undefined | null | void> =
        this._onDidChangeTreeData.event;

    constructor(private workspaceRoot: string) {}

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: FileSystemNode): vscode.TreeItem {
        const treeItem = new vscode.TreeItem(
            element.label,
            element.type === 'directory'
                ? vscode.TreeItemCollapsibleState.Collapsed
                : vscode.TreeItemCollapsibleState.None
        );

        // Set icon based on type
        if (element.type === 'directory') {
            treeItem.iconPath = new vscode.ThemeIcon('folder');
        } else {
            treeItem.iconPath = new vscode.ThemeIcon('file');
            treeItem.command = {
                command: 'vscode.open',
                title: 'Open File',
                arguments: [element.uri]
            };
        }

        treeItem.contextValue = element.type;
        treeItem.tooltip = element.uri.fsPath;
        treeItem.resourceUri = element.uri;

        return treeItem;
    }

    getChildren(element?: FileSystemNode): Thenable<FileSystemNode[]> {
        if (!this.workspaceRoot) {
            vscode.window.showInformationMessage('No folder opened');
            return Promise.resolve([]);
        }

        const dirPath = element ? element.uri.fsPath : this.workspaceRoot;

        return new Promise((resolve) => {
            fs.readdir(dirPath, { withFileTypes: true }, (err, entries) => {
                if (err) {
                    resolve([]);
                    return;
                }

                const nodes = entries
                    .filter(entry => !entry.name.startsWith('.'))
                    .map(entry => {
                        const uri = vscode.Uri.file(path.join(dirPath, entry.name));
                        return new FileSystemNode(
                            uri,
                            entry.isDirectory() ? 'directory' : 'file'
                        );
                    })
                    .sort((a, b) => {
                        // Directories first, then alphabetically
                        if (a.type !== b.type) {
                            return a.type === 'directory' ? -1 : 1;
                        }
                        return a.label.localeCompare(b.label);
                    });

                resolve(nodes);
            });
        });
    }
}

export function activate(context: vscode.ExtensionContext) {
    const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;

    if (workspaceRoot) {
        const fileSystemProvider = new FileSystemTreeDataProvider(workspaceRoot);

        vscode.window.registerTreeDataProvider(
            'myExtension.fileSystemTree',
            fileSystemProvider
        );

        // Refresh command
        context.subscriptions.push(
            vscode.commands.registerCommand('myExtension.refreshFileTree', () => {
                fileSystemProvider.refresh();
            })
        );
    }
}
```

### package.json for File System Tree

```json
{
    "contributes": {
        "views": {
            "explorer": [
                {
                    "id": "myExtension.fileSystemTree",
                    "name": "File System"
                }
            ]
        },
        "commands": [
            {
                "command": "myExtension.refreshFileTree",
                "title": "Refresh File Tree",
                "icon": "$(refresh)"
            }
        ],
        "menus": {
            "view/title": [
                {
                    "command": "myExtension.refreshFileTree",
                    "when": "view == myExtension.fileSystemTree",
                    "group": "navigation"
                }
            ]
        }
    }
}
```

## Context Menus and Inline Actions

### Adding Context Menus

```typescript
class ActionableTreeItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly id: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState
    ) {
        super(label, collapsibleState);
        this.contextValue = 'actionableItem';
    }
}

class ActionableTreeDataProvider implements vscode.TreeDataProvider<ActionableTreeItem> {

    private _onDidChangeTreeData: vscode.EventEmitter<ActionableTreeItem | undefined | null | void> =
        new vscode.EventEmitter<ActionableTreeItem | undefined | null | void>();

    readonly onDidChangeTreeData: vscode.Event<ActionableTreeItem | undefined | null | void> =
        this._onDidChangeTreeData.event;

    private items: ActionableTreeItem[] = [
        new ActionableTreeItem('Item 1', 'item1', vscode.TreeItemCollapsibleState.None),
        new ActionableTreeItem('Item 2', 'item2', vscode.TreeItemCollapsibleState.None),
        new ActionableTreeItem('Item 3', 'item3', vscode.TreeItemCollapsibleState.None)
    ];

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: ActionableTreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: ActionableTreeItem): Thenable<ActionableTreeItem[]> {
        if (!element) {
            return Promise.resolve(this.items);
        }
        return Promise.resolve([]);
    }

    addItem(label: string): void {
        const id = `item${this.items.length + 1}`;
        this.items.push(
            new ActionableTreeItem(label, id, vscode.TreeItemCollapsibleState.None)
        );
        this.refresh();
    }

    deleteItem(item: ActionableTreeItem): void {
        const index = this.items.findIndex(i => i.id === item.id);
        if (index !== -1) {
            this.items.splice(index, 1);
            this.refresh();
        }
    }
}

export function activate(context: vscode.ExtensionContext) {
    const treeDataProvider = new ActionableTreeDataProvider();

    vscode.window.registerTreeDataProvider(
        'myExtension.actionableTree',
        treeDataProvider
    );

    // Add item command
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.addItem', async () => {
            const label = await vscode.window.showInputBox({
                prompt: 'Enter item label'
            });
            if (label) {
                treeDataProvider.addItem(label);
            }
        })
    );

    // Delete item command
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.deleteItem', (item: ActionableTreeItem) => {
            treeDataProvider.deleteItem(item);
        })
    );

    // Edit item command
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.editItem', async (item: ActionableTreeItem) => {
            const newLabel = await vscode.window.showInputBox({
                prompt: 'Enter new label',
                value: item.label
            });
            if (newLabel) {
                item.label = newLabel;
                treeDataProvider.refresh();
            }
        })
    );
}
```

### package.json for Context Menus

```json
{
    "contributes": {
        "views": {
            "explorer": [
                {
                    "id": "myExtension.actionableTree",
                    "name": "Actionable Tree"
                }
            ]
        },
        "commands": [
            {
                "command": "myExtension.addItem",
                "title": "Add Item",
                "icon": "$(add)"
            },
            {
                "command": "myExtension.deleteItem",
                "title": "Delete Item",
                "icon": "$(trash)"
            },
            {
                "command": "myExtension.editItem",
                "title": "Edit Item",
                "icon": "$(edit)"
            }
        ],
        "menus": {
            "view/title": [
                {
                    "command": "myExtension.addItem",
                    "when": "view == myExtension.actionableTree",
                    "group": "navigation"
                }
            ],
            "view/item/context": [
                {
                    "command": "myExtension.editItem",
                    "when": "view == myExtension.actionableTree && viewItem == actionableItem",
                    "group": "inline"
                },
                {
                    "command": "myExtension.deleteItem",
                    "when": "view == myExtension.actionableTree && viewItem == actionableItem",
                    "group": "inline"
                }
            ]
        }
    }
}
```

## Multi-Root Workspace Support

### Workspace-Aware Tree Provider

```typescript
class WorkspaceTreeItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly workspaceFolder?: vscode.WorkspaceFolder,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None
    ) {
        super(label, collapsibleState);

        if (workspaceFolder) {
            this.contextValue = 'workspaceFolder';
            this.iconPath = new vscode.ThemeIcon('root-folder');
            this.tooltip = workspaceFolder.uri.fsPath;
        } else {
            this.contextValue = 'item';
            this.iconPath = new vscode.ThemeIcon('file');
        }
    }
}

class WorkspaceTreeDataProvider implements vscode.TreeDataProvider<WorkspaceTreeItem> {

    private _onDidChangeTreeData: vscode.EventEmitter<WorkspaceTreeItem | undefined | null | void> =
        new vscode.EventEmitter<WorkspaceTreeItem | undefined | null | void>();

    readonly onDidChangeTreeData: vscode.Event<WorkspaceTreeItem | undefined | null | void> =
        this._onDidChangeTreeData.event;

    constructor() {
        // Watch for workspace folder changes
        vscode.workspace.onDidChangeWorkspaceFolders(() => {
            this.refresh();
        });
    }

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: WorkspaceTreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: WorkspaceTreeItem): Thenable<WorkspaceTreeItem[]> {
        if (!element) {
            // Show workspace folders at root
            const folders = vscode.workspace.workspaceFolders || [];
            return Promise.resolve(
                folders.map(folder =>
                    new WorkspaceTreeItem(
                        folder.name,
                        folder,
                        vscode.TreeItemCollapsibleState.Collapsed
                    )
                )
            );
        } else if (element.workspaceFolder) {
            // Show items for this workspace folder
            return Promise.resolve([
                new WorkspaceTreeItem(`${element.label} - Item 1`),
                new WorkspaceTreeItem(`${element.label} - Item 2`),
                new WorkspaceTreeItem(`${element.label} - Item 3`)
            ]);
        }

        return Promise.resolve([]);
    }
}
```

## Drag and Drop Support

### Implementing Drag and Drop

```typescript
class DragDropTreeItem extends vscode.TreeItem {
    constructor(
        public readonly id: string,
        public readonly label: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState
    ) {
        super(label, collapsibleState);
        this.contextValue = 'draggableItem';
    }
}

class DragDropTreeDataProvider implements vscode.TreeDataProvider<DragDropTreeItem>, vscode.TreeDragAndDropController<DragDropTreeItem> {

    dropMimeTypes = ['application/vnd.code.tree.draggableTree'];
    dragMimeTypes = ['text/uri-list'];

    private _onDidChangeTreeData: vscode.EventEmitter<DragDropTreeItem | undefined | null | void> =
        new vscode.EventEmitter<DragDropTreeItem | undefined | null | void>();

    readonly onDidChangeTreeData: vscode.Event<DragDropTreeItem | undefined | null | void> =
        this._onDidChangeTreeData.event;

    private items: Map<string, DragDropTreeItem[]> = new Map([
        ['root', [
            new DragDropTreeItem('1', 'Item 1', vscode.TreeItemCollapsibleState.None),
            new DragDropTreeItem('2', 'Item 2', vscode.TreeItemCollapsibleState.None),
            new DragDropTreeItem('3', 'Item 3', vscode.TreeItemCollapsibleState.None)
        ]]
    ]);

    getTreeItem(element: DragDropTreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: DragDropTreeItem): Thenable<DragDropTreeItem[]> {
        if (!element) {
            return Promise.resolve(this.items.get('root') || []);
        }
        return Promise.resolve([]);
    }

    // Handle drag operation
    public async handleDrag(
        source: readonly DragDropTreeItem[],
        dataTransfer: vscode.DataTransfer,
        token: vscode.CancellationToken
    ): Promise<void> {
        dataTransfer.set(
            'application/vnd.code.tree.draggableTree',
            new vscode.DataTransferItem(source)
        );
    }

    // Handle drop operation
    public async handleDrop(
        target: DragDropTreeItem | undefined,
        dataTransfer: vscode.DataTransfer,
        token: vscode.CancellationToken
    ): Promise<void> {
        const transferItem = dataTransfer.get('application/vnd.code.tree.draggableTree');
        if (!transferItem) {
            return;
        }

        const items = transferItem.value as DragDropTreeItem[];
        const rootItems = this.items.get('root') || [];

        // Remove dragged items from current position
        items.forEach(item => {
            const index = rootItems.findIndex(i => i.id === item.id);
            if (index !== -1) {
                rootItems.splice(index, 1);
            }
        });

        // Insert at new position
        if (target) {
            const targetIndex = rootItems.findIndex(i => i.id === target.id);
            if (targetIndex !== -1) {
                rootItems.splice(targetIndex, 0, ...items);
            }
        } else {
            // Drop at end if no target
            rootItems.push(...items);
        }

        this.items.set('root', rootItems);
        this._onDidChangeTreeData.fire();
    }
}

export function activate(context: vscode.ExtensionContext) {
    const treeDataProvider = new DragDropTreeDataProvider();

    vscode.window.createTreeView('myExtension.draggableTree', {
        treeDataProvider,
        dragAndDropController: treeDataProvider
    });
}
```

### package.json for Drag and Drop

```json
{
    "contributes": {
        "views": {
            "explorer": [
                {
                    "id": "myExtension.draggableTree",
                    "name": "Draggable Tree"
                }
            ]
        }
    }
}
```

## Complete Example: Task Manager Tree

### Task Manager Implementation

```typescript
import * as vscode from 'vscode';

interface Task {
    id: string;
    name: string;
    status: 'pending' | 'in-progress' | 'completed';
    priority: 'low' | 'medium' | 'high';
    children?: Task[];
}

class TaskTreeItem extends vscode.TreeItem {
    constructor(
        public readonly task: Task,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState
    ) {
        super(task.name, collapsibleState);

        this.contextValue = `task-${task.status}`;
        this.tooltip = `${task.name} (${task.status}, ${task.priority} priority)`;
        this.description = task.status;

        // Set icon based on status
        switch (task.status) {
            case 'completed':
                this.iconPath = new vscode.ThemeIcon('check', new vscode.ThemeColor('testing.iconPassed'));
                break;
            case 'in-progress':
                this.iconPath = new vscode.ThemeIcon('sync~spin', new vscode.ThemeColor('testing.iconQueued'));
                break;
            case 'pending':
                this.iconPath = new vscode.ThemeIcon('circle-outline');
                break;
        }

        // Add command to view details
        this.command = {
            command: 'myExtension.viewTaskDetails',
            title: 'View Task Details',
            arguments: [task]
        };
    }
}

class TaskTreeDataProvider implements vscode.TreeDataProvider<TaskTreeItem> {

    private _onDidChangeTreeData: vscode.EventEmitter<TaskTreeItem | undefined | null | void> =
        new vscode.EventEmitter<TaskTreeItem | undefined | null | void>();

    readonly onDidChangeTreeData: vscode.Event<TaskTreeItem | undefined | null | void> =
        this._onDidChangeTreeData.event;

    private tasks: Task[] = [
        {
            id: '1',
            name: 'Project Setup',
            status: 'completed',
            priority: 'high',
            children: [
                { id: '1.1', name: 'Initialize repository', status: 'completed', priority: 'high' },
                { id: '1.2', name: 'Configure tools', status: 'completed', priority: 'medium' }
            ]
        },
        {
            id: '2',
            name: 'Development',
            status: 'in-progress',
            priority: 'high',
            children: [
                { id: '2.1', name: 'Implement features', status: 'in-progress', priority: 'high' },
                { id: '2.2', name: 'Write tests', status: 'pending', priority: 'medium' }
            ]
        },
        {
            id: '3',
            name: 'Documentation',
            status: 'pending',
            priority: 'low'
        }
    ];

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: TaskTreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: TaskTreeItem): Thenable<TaskTreeItem[]> {
        if (!element) {
            // Root level tasks
            return Promise.resolve(
                this.tasks.map(task =>
                    new TaskTreeItem(
                        task,
                        task.children && task.children.length > 0
                            ? vscode.TreeItemCollapsibleState.Collapsed
                            : vscode.TreeItemCollapsibleState.None
                    )
                )
            );
        } else if (element.task.children) {
            // Child tasks
            return Promise.resolve(
                element.task.children.map(task =>
                    new TaskTreeItem(task, vscode.TreeItemCollapsibleState.None)
                )
            );
        }

        return Promise.resolve([]);
    }

    // Task management methods
    addTask(name: string, priority: 'low' | 'medium' | 'high', parentId?: string): void {
        const newTask: Task = {
            id: Date.now().toString(),
            name,
            status: 'pending',
            priority
        };

        if (parentId) {
            const parent = this.findTask(parentId);
            if (parent) {
                if (!parent.children) {
                    parent.children = [];
                }
                parent.children.push(newTask);
            }
        } else {
            this.tasks.push(newTask);
        }

        this.refresh();
    }

    updateTaskStatus(taskId: string, status: 'pending' | 'in-progress' | 'completed'): void {
        const task = this.findTask(taskId);
        if (task) {
            task.status = status;
            this.refresh();
        }
    }

    deleteTask(taskId: string): void {
        this.tasks = this.tasks.filter(t => t.id !== taskId);
        this.tasks.forEach(task => {
            if (task.children) {
                task.children = task.children.filter(c => c.id !== taskId);
            }
        });
        this.refresh();
    }

    private findTask(taskId: string, tasks: Task[] = this.tasks): Task | undefined {
        for (const task of tasks) {
            if (task.id === taskId) {
                return task;
            }
            if (task.children) {
                const found = this.findTask(taskId, task.children);
                if (found) {
                    return found;
                }
            }
        }
        return undefined;
    }
}

export function activate(context: vscode.ExtensionContext) {
    const taskProvider = new TaskTreeDataProvider();

    vscode.window.registerTreeDataProvider('myExtension.tasks', taskProvider);

    // View task details
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.viewTaskDetails', (task: Task) => {
            vscode.window.showInformationMessage(
                `Task: ${task.name}\nStatus: ${task.status}\nPriority: ${task.priority}`
            );
        })
    );

    // Add task
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.addTask', async () => {
            const name = await vscode.window.showInputBox({
                prompt: 'Enter task name'
            });
            if (!name) return;

            const priority = await vscode.window.showQuickPick(
                ['low', 'medium', 'high'],
                { placeHolder: 'Select priority' }
            ) as 'low' | 'medium' | 'high';

            if (priority) {
                taskProvider.addTask(name, priority);
            }
        })
    );

    // Mark as in progress
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.markInProgress', (item: TaskTreeItem) => {
            taskProvider.updateTaskStatus(item.task.id, 'in-progress');
        })
    );

    // Mark as completed
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.markCompleted', (item: TaskTreeItem) => {
            taskProvider.updateTaskStatus(item.task.id, 'completed');
        })
    );

    // Delete task
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.deleteTask', (item: TaskTreeItem) => {
            taskProvider.deleteTask(item.task.id);
        })
    );

    // Refresh tasks
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.refreshTasks', () => {
            taskProvider.refresh();
        })
    );
}
```

### package.json for Task Manager

```json
{
    "contributes": {
        "views": {
            "explorer": [
                {
                    "id": "myExtension.tasks",
                    "name": "Task Manager",
                    "icon": "$(checklist)",
                    "contextualTitle": "Tasks"
                }
            ]
        },
        "commands": [
            {
                "command": "myExtension.addTask",
                "title": "Add Task",
                "icon": "$(add)"
            },
            {
                "command": "myExtension.refreshTasks",
                "title": "Refresh Tasks",
                "icon": "$(refresh)"
            },
            {
                "command": "myExtension.markInProgress",
                "title": "Mark as In Progress",
                "icon": "$(play)"
            },
            {
                "command": "myExtension.markCompleted",
                "title": "Mark as Completed",
                "icon": "$(check)"
            },
            {
                "command": "myExtension.deleteTask",
                "title": "Delete Task",
                "icon": "$(trash)"
            },
            {
                "command": "myExtension.viewTaskDetails",
                "title": "View Task Details"
            }
        ],
        "menus": {
            "view/title": [
                {
                    "command": "myExtension.addTask",
                    "when": "view == myExtension.tasks",
                    "group": "navigation@1"
                },
                {
                    "command": "myExtension.refreshTasks",
                    "when": "view == myExtension.tasks",
                    "group": "navigation@2"
                }
            ],
            "view/item/context": [
                {
                    "command": "myExtension.markInProgress",
                    "when": "view == myExtension.tasks && viewItem == task-pending",
                    "group": "inline@1"
                },
                {
                    "command": "myExtension.markCompleted",
                    "when": "view == myExtension.tasks && viewItem =~ /task-(pending|in-progress)/",
                    "group": "inline@2"
                },
                {
                    "command": "myExtension.deleteTask",
                    "when": "view == myExtension.tasks",
                    "group": "inline@3"
                }
            ]
        }
    }
}
```

## Welcome Views

### Creating Welcome Views

```typescript
// No special TypeScript code needed - configured in package.json

// Optional: Command to clear welcome view state for testing
export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.resetWelcome', () => {
            context.globalState.update('myExtension.welcomeShown', undefined);
        })
    );
}
```

### package.json for Welcome View

```json
{
    "contributes": {
        "views": {
            "explorer": [
                {
                    "id": "myExtension.welcome",
                    "name": "Getting Started"
                }
            ]
        },
        "viewsWelcome": [
            {
                "view": "myExtension.welcome",
                "contents": "Welcome to My Extension!\n[Open Settings](command:workbench.action.openSettings)\n[Create New Item](command:myExtension.createItem)\nFor more information, visit our [documentation](https://example.com)."
            }
        ]
    }
}
```

## Best Practices

### 1. Efficient Data Loading

```typescript
// ✅ Good: Lazy loading with caching
class EfficientTreeDataProvider implements vscode.TreeDataProvider<string> {
    private cache = new Map<string, string[]>();

    getTreeItem(element: string): vscode.TreeItem {
        return new vscode.TreeItem(element);
    }

    async getChildren(element?: string): Promise<string[]> {
        const key = element || 'root';

        if (this.cache.has(key)) {
            return this.cache.get(key)!;
        }

        const children = await this.loadChildren(key);
        this.cache.set(key, children);
        return children;
    }

    private async loadChildren(key: string): Promise<string[]> {
        // Simulate async data loading
        await new Promise(resolve => setTimeout(resolve, 100));
        return [`${key}-child-1`, `${key}-child-2`];
    }

    clearCache(): void {
        this.cache.clear();
    }
}

// ❌ Bad: Loading all data upfront
class InefficientTreeDataProvider implements vscode.TreeDataProvider<string> {
    private allData: Map<string, string[]>;

    constructor() {
        // Loading everything at initialization
        this.allData = this.loadAllData();
    }

    private loadAllData(): Map<string, string[]> {
        // This could be expensive
        return new Map();
    }
}
```

### 2. Proper Event Handling

```typescript
// ✅ Good: Targeted refresh
class SmartTreeDataProvider implements vscode.TreeDataProvider<string> {
    private _onDidChangeTreeData = new vscode.EventEmitter<string | undefined>();
    readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

    // Refresh specific element
    refreshElement(element: string): void {
        this._onDidChangeTreeData.fire(element);
    }

    // Refresh entire tree only when necessary
    refreshAll(): void {
        this._onDidChangeTreeData.fire(undefined);
    }
}

// ❌ Bad: Always refreshing entire tree
class NaiveTreeDataProvider implements vscode.TreeDataProvider<string> {
    private _onDidChangeTreeData = new vscode.EventEmitter<void>();
    readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

    refresh(): void {
        // Always refreshes everything
        this._onDidChangeTreeData.fire();
    }
}
```

### 3. Context Value Design

```typescript
// ✅ Good: Specific context values
class GoodTreeItem extends vscode.TreeItem {
    constructor(type: 'file' | 'folder', readonly: boolean) {
        super('Item');
        // Allows for precise menu targeting
        this.contextValue = readonly ? `${type}-readonly` : type;
    }
}

// ❌ Bad: Generic context values
class BadTreeItem extends vscode.TreeItem {
    constructor() {
        super('Item');
        // Too generic, limits menu options
        this.contextValue = 'item';
    }
}
```

### 4. Memory Management

```typescript
// ✅ Good: Dispose resources properly
class ProperTreeView {
    private disposables: vscode.Disposable[] = [];

    constructor(context: vscode.ExtensionContext) {
        const provider = new MyTreeDataProvider();
        const treeView = vscode.window.createTreeView('myView', {
            treeDataProvider: provider
        });

        this.disposables.push(treeView);
        this.disposables.push(provider);

        context.subscriptions.push(...this.disposables);
    }

    dispose(): void {
        this.disposables.forEach(d => d.dispose());
    }
}

// ❌ Bad: Memory leaks
class LeakyTreeView {
    constructor() {
        const provider = new MyTreeDataProvider();
        vscode.window.createTreeView('myView', {
            treeDataProvider: provider
        });
        // No disposal, resources leak
    }
}
```

### 5. Error Handling

```typescript
// ✅ Good: Graceful error handling
class RobustTreeDataProvider implements vscode.TreeDataProvider<string> {

    async getChildren(element?: string): Promise<string[]> {
        try {
            return await this.loadData(element);
        } catch (error) {
            vscode.window.showErrorMessage(
                `Failed to load tree data: ${error instanceof Error ? error.message : 'Unknown error'}`
            );
            return [];
        }
    }

    private async loadData(element?: string): Promise<string[]> {
        // Data loading logic
        return [];
    }
}

// ❌ Bad: Unhandled errors
class FragileTreeDataProvider implements vscode.TreeDataProvider<string> {

    async getChildren(element?: string): Promise<string[]> {
        // No error handling - crashes on failure
        return await this.loadData(element);
    }

    private async loadData(element?: string): Promise<string[]> {
        throw new Error('Network error');
    }
}
```

## Summary

You've learned:

- ✅ TreeDataProvider interface and implementation
- ✅ Creating custom tree items with icons and context
- ✅ Refreshing tree views efficiently
- ✅ Adding context menus and inline actions
- ✅ Multi-root workspace support
- ✅ Drag and drop functionality
- ✅ Complete real-world examples (file system, task manager)
- ✅ Welcome views
- ✅ Best practices for performance and maintainability

## Exercise

Create a "Bookmark Manager" tree view with:
1. Hierarchical bookmark structure (folders and bookmarks)
2. Add/edit/delete operations
3. Icons based on bookmark type (URL, file, folder)
4. Context menus with appropriate actions
5. Drag and drop to reorganize bookmarks
6. Search/filter functionality
7. Persist bookmarks to workspace state
8. Welcome view for first-time users

## Next Steps

Continue to [3.4 Sidebar and Panel Integration](./3.4-sidebar-and-panel-integration.md) to learn about organizing tree views in custom containers and panels.

## Additional Resources

- [Tree View API](https://code.visualstudio.com/api/extension-guides/tree-view)
- [TreeDataProvider Interface](https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider)
- [Tree View Sample](https://github.com/microsoft/vscode-extension-samples/tree/main/tree-view-sample)
- [Custom View Sample](https://github.com/microsoft/vscode-extension-samples/tree/main/custom-view-sample)
