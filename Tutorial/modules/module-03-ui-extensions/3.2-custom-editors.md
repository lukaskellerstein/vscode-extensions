# 3.2 Custom Editors

## Introduction

Custom editors allow you to create specialized editing experiences for specific file types. Unlike webviews that display arbitrary content, custom editors integrate deeply with VS Code's file system, providing full editing capabilities including undo/redo, save, dirty state management, and more.

## Types of Custom Editors

### Custom Text Editors
- Work with text-based files
- Built on top of VS Code's text document model
- Automatic undo/redo support
- Example: Markdown WYSIWYG editor

### Custom Editors (Binary)
- Work with any file type (text or binary)
- Full control over file operations
- Manual undo/redo implementation
- Example: Image editor, hex editor

## Custom Text Editor

### Basic Custom Text Editor

```typescript
import * as vscode from 'vscode';

export class MyCustomTextEditorProvider implements vscode.CustomTextEditorProvider {

    public static register(context: vscode.ExtensionContext): vscode.Disposable {
        const provider = new MyCustomTextEditorProvider(context);
        const providerRegistration = vscode.window.registerCustomEditorProvider(
            'myExtension.customEditor',
            provider
        );
        return providerRegistration;
    }

    constructor(private readonly context: vscode.ExtensionContext) {}

    public async resolveCustomTextEditor(
        document: vscode.TextDocument,
        webviewPanel: vscode.WebviewPanel,
        _token: vscode.CancellationToken
    ): Promise<void> {
        // Setup webview
        webviewPanel.webview.options = {
            enableScripts: true
        };
        webviewPanel.webview.html = this.getHtmlForWebview(webviewPanel.webview);

        // Update webview when document changes
        const changeDocumentSubscription = vscode.workspace.onDidChangeTextDocument(e => {
            if (e.document.uri.toString() === document.uri.toString()) {
                this.updateWebview(webviewPanel.webview, document);
            }
        });

        // Clean up
        webviewPanel.onDidDispose(() => {
            changeDocumentSubscription.dispose();
        });

        // Handle messages from webview
        webviewPanel.webview.onDidReceiveMessage(
            message => {
                switch (message.type) {
                    case 'update':
                        this.updateTextDocument(document, message.content);
                        return;
                }
            }
        );

        // Initial update
        this.updateWebview(webviewPanel.webview, document);
    }

    private updateWebview(webview: vscode.Webview, document: vscode.TextDocument) {
        webview.postMessage({
            type: 'update',
            content: document.getText()
        });
    }

    private updateTextDocument(document: vscode.TextDocument, content: string) {
        const edit = new vscode.WorkspaceEdit();

        // Replace entire document
        edit.replace(
            document.uri,
            new vscode.Range(0, 0, document.lineCount, 0),
            content
        );

        return vscode.workspace.applyEdit(edit);
    }

    private getHtmlForWebview(webview: vscode.Webview): string {
        return `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Custom Text Editor</title>
            <style>
                textarea {
                    width: 100%;
                    height: 100vh;
                    background: var(--vscode-editor-background);
                    color: var(--vscode-editor-foreground);
                    border: none;
                    font-family: var(--vscode-editor-font-family);
                    font-size: var(--vscode-editor-font-size);
                    padding: 10px;
                    resize: none;
                }
            </style>
        </head>
        <body>
            <textarea id="editor"></textarea>
            <script>
                const vscode = acquireVsCodeApi();
                const textarea = document.getElementById('editor');

                // Update editor when document changes
                window.addEventListener('message', event => {
                    const message = event.data;
                    if (message.type === 'update') {
                        textarea.value = message.content;
                    }
                });

                // Send changes to extension
                textarea.addEventListener('input', () => {
                    vscode.postMessage({
                        type: 'update',
                        content: textarea.value
                    });
                });
            </script>
        </body>
        </html>`;
    }
}
```

### Register in package.json

```json
{
  "contributes": {
    "customEditors": [
      {
        "viewType": "myExtension.customEditor",
        "displayName": "My Custom Editor",
        "selector": [
          {
            "filenamePattern": "*.custom"
          }
        ],
        "priority": "default"
      }
    ]
  }
}
```

### Activation

```typescript
export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        MyCustomTextEditorProvider.register(context)
    );
}
```

## JSON Editor Example

```typescript
interface JsonData {
    [key: string]: any;
}

export class JsonEditorProvider implements vscode.CustomTextEditorProvider {

    public static register(context: vscode.ExtensionContext): vscode.Disposable {
        return vscode.window.registerCustomEditorProvider(
            'myExtension.jsonEditor',
            new JsonEditorProvider(context),
            {
                webviewOptions: {
                    retainContextWhenHidden: true
                },
                supportsMultipleEditorsPerDocument: false
            }
        );
    }

    constructor(private readonly context: vscode.ExtensionContext) {}

    public async resolveCustomTextEditor(
        document: vscode.TextDocument,
        webviewPanel: vscode.WebviewPanel,
        _token: vscode.CancellationToken
    ): Promise<void> {
        webviewPanel.webview.options = {
            enableScripts: true
        };

        webviewPanel.webview.html = this.getHtmlForWebview(webviewPanel.webview);

        function updateWebview() {
            webviewPanel.webview.postMessage({
                type: 'update',
                content: parseJson(document.getText())
            });
        }

        function parseJson(text: string): JsonData | null {
            try {
                return JSON.parse(text);
            } catch {
                vscode.window.showErrorMessage('Invalid JSON');
                return null;
            }
        }

        // Document change listener
        const changeDocumentSubscription = vscode.workspace.onDidChangeTextDocument(e => {
            if (e.document.uri.toString() === document.uri.toString()) {
                updateWebview();
            }
        });

        // Message handler
        webviewPanel.webview.onDidReceiveMessage(async message => {
            switch (message.type) {
                case 'update':
                    await this.updateDocument(document, message.content);
                    return;
                case 'add':
                    await this.addProperty(document, message.key, message.value);
                    return;
                case 'delete':
                    await this.deleteProperty(document, message.key);
                    return;
            }
        });

        // Cleanup
        webviewPanel.onDidDispose(() => {
            changeDocumentSubscription.dispose();
        });

        updateWebview();
    }

    private async updateDocument(document: vscode.TextDocument, content: JsonData) {
        const edit = new vscode.WorkspaceEdit();
        const fullText = JSON.stringify(content, null, 2);

        edit.replace(
            document.uri,
            new vscode.Range(0, 0, document.lineCount, 0),
            fullText
        );

        return vscode.workspace.applyEdit(edit);
    }

    private async addProperty(document: vscode.TextDocument, key: string, value: any) {
        try {
            const json = JSON.parse(document.getText());
            json[key] = value;
            await this.updateDocument(document, json);
        } catch (error) {
            vscode.window.showErrorMessage('Failed to add property');
        }
    }

    private async deleteProperty(document: vscode.TextDocument, key: string) {
        try {
            const json = JSON.parse(document.getText());
            delete json[key];
            await this.updateDocument(document, json);
        } catch (error) {
            vscode.window.showErrorMessage('Failed to delete property');
        }
    }

    private getHtmlForWebview(webview: vscode.Webview): string {
        return `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <style>
                body {
                    padding: 20px;
                    font-family: var(--vscode-font-family);
                }
                .property {
                    display: flex;
                    gap: 10px;
                    margin: 10px 0;
                    align-items: center;
                }
                input {
                    padding: 5px;
                    background: var(--vscode-input-background);
                    color: var(--vscode-input-foreground);
                    border: 1px solid var(--vscode-input-border);
                }
                button {
                    padding: 5px 10px;
                    background: var(--vscode-button-background);
                    color: var(--vscode-button-foreground);
                    border: none;
                    cursor: pointer;
                }
            </style>
        </head>
        <body>
            <h2>JSON Editor</h2>
            <div id="properties"></div>
            <hr>
            <h3>Add Property</h3>
            <div>
                <input type="text" id="newKey" placeholder="Key">
                <input type="text" id="newValue" placeholder="Value">
                <button onclick="addProperty()">Add</button>
            </div>

            <script>
                const vscode = acquireVsCodeApi();
                let currentData = {};

                window.addEventListener('message', event => {
                    const message = event.data;
                    if (message.type === 'update' && message.content) {
                        currentData = message.content;
                        renderProperties();
                    }
                });

                function renderProperties() {
                    const container = document.getElementById('properties');
                    container.innerHTML = '';

                    Object.keys(currentData).forEach(key => {
                        const div = document.createElement('div');
                        div.className = 'property';
                        div.innerHTML = \`
                            <strong>\${key}:</strong>
                            <input type="text" value="\${currentData[key]}"
                                   onchange="updateValue('\${key}', this.value)">
                            <button onclick="deleteProperty('\${key}')">Delete</button>
                        \`;
                        container.appendChild(div);
                    });
                }

                function updateValue(key, value) {
                    currentData[key] = value;
                    vscode.postMessage({
                        type: 'update',
                        content: currentData
                    });
                }

                function deleteProperty(key) {
                    vscode.postMessage({
                        type: 'delete',
                        key: key
                    });
                }

                function addProperty() {
                    const key = document.getElementById('newKey').value;
                    const value = document.getElementById('newValue').value;

                    if (key && value) {
                        vscode.postMessage({
                            type: 'add',
                            key: key,
                            value: value
                        });

                        document.getElementById('newKey').value = '';
                        document.getElementById('newValue').value = '';
                    }
                }
            </script>
        </body>
        </html>`;
    }
}
```

## Custom Editor (Binary Files)

### Basic Custom Editor Provider

```typescript
export class ImageEditorProvider implements vscode.CustomReadonlyEditorProvider<ImageDocument> {

    private static readonly viewType = 'myExtension.imageEditor';

    public static register(context: vscode.ExtensionContext): vscode.Disposable {
        return vscode.window.registerCustomEditorProvider(
            ImageEditorProvider.viewType,
            new ImageEditorProvider(context),
            {
                supportsMultipleEditorsPerDocument: false,
                webviewOptions: {
                    retainContextWhenHidden: true
                }
            }
        );
    }

    constructor(private readonly context: vscode.ExtensionContext) {}

    async openCustomDocument(
        uri: vscode.Uri,
        openContext: vscode.CustomDocumentOpenContext,
        _token: vscode.CancellationToken
    ): Promise<ImageDocument> {
        const document = await ImageDocument.create(uri, openContext.backupId);
        return document;
    }

    async resolveCustomEditor(
        document: ImageDocument,
        webviewPanel: vscode.WebviewPanel,
        _token: vscode.CancellationToken
    ): Promise<void> {
        webviewPanel.webview.options = {
            enableScripts: true
        };

        webviewPanel.webview.html = this.getHtmlForWebview(
            webviewPanel.webview,
            document
        );
    }

    private getHtmlForWebview(webview: vscode.Webview, document: ImageDocument): string {
        const imageUri = webview.asWebviewUri(document.uri);

        return `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <style>
                body {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 100vh;
                    margin: 0;
                    background: var(--vscode-editor-background);
                }
                img {
                    max-width: 100%;
                    max-height: 100%;
                }
            </style>
        </head>
        <body>
            <img src="${imageUri}" alt="Image">
        </body>
        </html>`;
    }
}

class ImageDocument implements vscode.CustomDocument {
    uri: vscode.Uri;

    private constructor(
        uri: vscode.Uri,
        private readonly backupId: string | undefined
    ) {
        this.uri = uri;
    }

    static async create(
        uri: vscode.Uri,
        backupId: string | undefined
    ): Promise<ImageDocument> {
        return new ImageDocument(uri, backupId);
    }

    dispose(): void {
        // Cleanup
    }
}
```

## Editable Custom Editor with Undo/Redo

```typescript
interface DrawingEdit {
    readonly type: 'add' | 'remove';
    readonly shape: Shape;
}

interface Shape {
    id: string;
    type: 'circle' | 'rectangle';
    x: number;
    y: number;
    width: number;
    height: number;
    color: string;
}

class DrawingDocument implements vscode.CustomDocument {
    uri: vscode.Uri;

    private _shapes: Shape[] = [];
    private _edits: DrawingEdit[] = [];
    private _savedEdits: DrawingEdit[] = [];

    private readonly _onDidChange = new vscode.EventEmitter<{
        readonly content: Shape[];
        readonly edits: readonly DrawingEdit[];
    }>();
    public readonly onDidChange = this._onDidChange.event;

    private readonly _onDidDispose = new vscode.EventEmitter<void>();
    public readonly onDidDispose = this._onDidDispose.event;

    constructor(
        uri: vscode.Uri,
        initialContent: Shape[]
    ) {
        this.uri = uri;
        this._shapes = initialContent;
    }

    get shapes(): readonly Shape[] {
        return this._shapes;
    }

    makeEdit(edit: DrawingEdit) {
        this._edits.push(edit);

        if (edit.type === 'add') {
            this._shapes.push(edit.shape);
        } else {
            const index = this._shapes.findIndex(s => s.id === edit.shape.id);
            if (index !== -1) {
                this._shapes.splice(index, 1);
            }
        }

        this._onDidChange.fire({
            content: this._shapes,
            edits: this._edits
        });
    }

    dispose(): void {
        this._onDidDispose.fire();
        this._onDidDispose.dispose();
        this._onDidChange.dispose();
    }

    get isDirty(): boolean {
        return this._edits.length > this._savedEdits.length;
    }

    async save(): Promise<void> {
        const content = JSON.stringify(this._shapes, null, 2);
        await vscode.workspace.fs.writeFile(this.uri, Buffer.from(content));
        this._savedEdits = [...this._edits];
    }

    async revert(): Promise<void> {
        const content = await vscode.workspace.fs.readFile(this.uri);
        this._shapes = JSON.parse(content.toString());
        this._edits = [];
        this._savedEdits = [];

        this._onDidChange.fire({
            content: this._shapes,
            edits: []
        });
    }
}

export class DrawingEditorProvider implements vscode.CustomEditorProvider<DrawingDocument> {

    public static register(context: vscode.ExtensionContext): vscode.Disposable {
        return vscode.window.registerCustomEditorProvider(
            'myExtension.drawingEditor',
            new DrawingEditorProvider(context),
            {
                webviewOptions: {
                    retainContextWhenHidden: true
                },
                supportsMultipleEditorsPerDocument: false
            }
        );
    }

    constructor(private readonly context: vscode.ExtensionContext) {}

    async openCustomDocument(
        uri: vscode.Uri,
        openContext: vscode.CustomDocumentOpenContext,
        _token: vscode.CancellationToken
    ): Promise<DrawingDocument> {
        let content: Shape[] = [];

        try {
            const fileContent = await vscode.workspace.fs.readFile(uri);
            content = JSON.parse(fileContent.toString());
        } catch {
            // New file or invalid JSON
            content = [];
        }

        return new DrawingDocument(uri, content);
    }

    async resolveCustomEditor(
        document: DrawingDocument,
        webviewPanel: vscode.WebviewPanel,
        _token: vscode.CancellationToken
    ): Promise<void> {
        webviewPanel.webview.options = {
            enableScripts: true
        };

        webviewPanel.webview.html = this.getHtmlForWebview(webviewPanel.webview);

        // Send initial content
        webviewPanel.webview.postMessage({
            type: 'init',
            shapes: document.shapes
        });

        // Handle document changes
        const changeSubscription = document.onDidChange(e => {
            webviewPanel.webview.postMessage({
                type: 'update',
                shapes: e.content
            });
        });

        // Handle webview messages
        webviewPanel.webview.onDidReceiveMessage(message => {
            switch (message.type) {
                case 'addShape':
                    document.makeEdit({
                        type: 'add',
                        shape: message.shape
                    });
                    return;
                case 'removeShape':
                    const shape = document.shapes.find(s => s.id === message.id);
                    if (shape) {
                        document.makeEdit({
                            type: 'remove',
                            shape: shape
                        });
                    }
                    return;
            }
        });

        webviewPanel.onDidDispose(() => {
            changeSubscription.dispose();
        });
    }

    async saveCustomDocument(
        document: DrawingDocument,
        cancellation: vscode.CancellationToken
    ): Promise<void> {
        await document.save();
    }

    async saveCustomDocumentAs(
        document: DrawingDocument,
        destination: vscode.Uri,
        cancellation: vscode.CancellationToken
    ): Promise<void> {
        const content = JSON.stringify(document.shapes, null, 2);
        await vscode.workspace.fs.writeFile(destination, Buffer.from(content));
    }

    async revertCustomDocument(
        document: DrawingDocument,
        cancellation: vscode.CancellationToken
    ): Promise<void> {
        await document.revert();
    }

    async backupCustomDocument(
        document: DrawingDocument,
        context: vscode.CustomDocumentBackupContext,
        cancellation: vscode.CancellationToken
    ): Promise<vscode.CustomDocumentBackup> {
        return {
            id: context.destination.toString(),
            delete: async () => {
                try {
                    await vscode.workspace.fs.delete(context.destination);
                } catch {
                    // Ignore
                }
            }
        };
    }

    private getHtmlForWebview(webview: vscode.Webview): string {
        return `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <style>
                body { margin: 0; padding: 20px; }
                canvas {
                    border: 1px solid var(--vscode-panel-border);
                    cursor: crosshair;
                }
                .controls { margin-bottom: 10px; }
                button {
                    margin-right: 5px;
                    padding: 5px 10px;
                    background: var(--vscode-button-background);
                    color: var(--vscode-button-foreground);
                    border: none;
                }
            </style>
        </head>
        <body>
            <div class="controls">
                <button onclick="setTool('circle')">Circle</button>
                <button onclick="setTool('rectangle')">Rectangle</button>
                <input type="color" id="color" value="#ff0000">
            </div>
            <canvas id="canvas" width="800" height="600"></canvas>

            <script>
                const vscode = acquireVsCodeApi();
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                let currentTool = 'circle';
                let shapes = [];

                function setTool(tool) {
                    currentTool = tool;
                }

                function drawShapes() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    shapes.forEach(shape => {
                        ctx.fillStyle = shape.color;
                        if (shape.type === 'circle') {
                            ctx.beginPath();
                            ctx.arc(shape.x, shape.y, shape.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                        }
                    });
                }

                canvas.addEventListener('click', e => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const color = document.getElementById('color').value;

                    const shape = {
                        id: Date.now().toString(),
                        type: currentTool,
                        x: x,
                        y: y,
                        width: 50,
                        height: 50,
                        color: color
                    };

                    vscode.postMessage({
                        type: 'addShape',
                        shape: shape
                    });
                });

                window.addEventListener('message', event => {
                    const message = event.data;
                    switch (message.type) {
                        case 'init':
                        case 'update':
                            shapes = message.shapes;
                            drawShapes();
                            break;
                    }
                });
            </script>
        </body>
        </html>`;
    }
}
```

## Best Practices

### 1. Efficient Updates

```typescript
// ✅ Good: Debounced updates
let updateTimeout: NodeJS.Timeout | undefined;

function scheduleUpdate() {
    if (updateTimeout) {
        clearTimeout(updateTimeout);
    }
    updateTimeout = setTimeout(() => {
        updateWebview();
    }, 300);
}

// ❌ Bad: Update on every keystroke
textarea.addEventListener('input', () => {
    updateWebview(); // Too frequent
});
```

### 2. Handle Dirty State

```typescript
// Implement dirty tracking
class MyDocument implements vscode.CustomDocument {
    private _isDirty = false;

    get isDirty(): boolean {
        return this._isDirty;
    }

    makeEdit() {
        this._isDirty = true;
        this._onDidChange.fire();
    }
}
```

### 3. Support Multiple Editors

```json
{
  "customEditors": [
    {
      "viewType": "myExtension.editor",
      "displayName": "My Editor",
      "selector": [
        { "filenamePattern": "*.custom" }
      ],
      "priority": "option"
    }
  ]
}
```

**Priority options:**
- **default**: Default editor
- **option**: Available as option
- **exclusive**: Only editor for this file type

### 4. Implement Proper Cleanup

```typescript
class MyDocument implements vscode.CustomDocument {
    private subscriptions: vscode.Disposable[] = [];

    dispose(): void {
        this.subscriptions.forEach(s => s.dispose());
        this._onDidDispose.fire();
        this._onDidDispose.dispose();
        this._onDidChange.dispose();
    }
}
```

## Summary

You've learned:

- ✅ Custom text editors vs custom editors
- ✅ Creating custom text editors for text files
- ✅ Building custom editors for binary files
- ✅ Implementing undo/redo
- ✅ Managing dirty state and save operations
- ✅ Backup and restore functionality
- ✅ Best practices for custom editors

## Exercise

Create a "Markdown Visual Editor" that:
1. Opens `.md` files
2. Provides WYSIWYG editing interface
3. Supports heading, bold, italic, lists
4. Shows live preview
5. Implements proper save/undo/redo
6. Handles dirty state correctly

## Next Steps

Continue to [3.3 Tree Views and Data Providers](./3.3-tree-views-and-data-providers.md) to learn about creating custom tree views.

## Additional Resources

- [Custom Editors API](https://code.visualstudio.com/api/extension-guides/custom-editors)
- [Custom Editor Sample](https://github.com/microsoft/vscode-extension-samples/tree/main/custom-editor-sample)
