# 2.2 Configuration and Settings

## Introduction

Configuration is how your extension provides customizable settings to users. VS Code's configuration system is powerful, type-safe, and integrates seamlessly with the Settings UI. This lesson covers everything from basic settings to advanced configuration patterns.

## Why Configuration Matters

Good configuration allows users to:
- **Customize behavior** to match their workflow
- **Toggle features** on/off
- **Set preferences** like colors, formats, paths
- **Override defaults** at user/workspace/folder level

## Configuration Basics

### Declaring Configuration Schema

All configuration starts in `package.json`:

```json
{
  "contributes": {
    "configuration": {
      "title": "My Extension",
      "properties": {
        "myExtension.enable": {
          "type": "boolean",
          "default": true,
          "description": "Enable/disable the extension"
        },
        "myExtension.maxItems": {
          "type": "number",
          "default": 10,
          "description": "Maximum number of items to display"
        }
      }
    }
  }
}
```

**Key Properties:**
- **title**: Section name in Settings UI
- **properties**: Object with setting definitions
- **type**: Data type (boolean, string, number, array, object)
- **default**: Default value
- **description**: Help text for users

## Configuration Types

### Boolean Settings

```json
{
  "myExtension.autoSave": {
    "type": "boolean",
    "default": false,
    "description": "Automatically save changes"
  },
  "myExtension.showWarnings": {
    "type": "boolean",
    "default": true,
    "markdownDescription": "Show warnings in the **Problems** panel"
  }
}
```

### String Settings

```json
{
  "myExtension.outputFormat": {
    "type": "string",
    "default": "json",
    "description": "Output format"
  },
  "myExtension.customPath": {
    "type": "string",
    "default": "${workspaceFolder}/output",
    "description": "Path for output files"
  }
}
```

### Number Settings

```json
{
  "myExtension.timeout": {
    "type": "number",
    "default": 5000,
    "minimum": 1000,
    "maximum": 30000,
    "description": "Timeout in milliseconds"
  },
  "myExtension.fontSize": {
    "type": "number",
    "default": 14,
    "minimum": 8,
    "maximum": 72,
    "markdownDescription": "Font size in pixels"
  }
}
```

### Enum Settings (Dropdown)

```json
{
  "myExtension.logLevel": {
    "type": "string",
    "default": "info",
    "enum": [
      "debug",
      "info",
      "warn",
      "error"
    ],
    "enumDescriptions": [
      "Show all messages including debug",
      "Show informational messages and above",
      "Show warnings and errors only",
      "Show errors only"
    ],
    "description": "Logging level"
  }
}
```

### Array Settings

```json
{
  "myExtension.excludePaths": {
    "type": "array",
    "default": ["node_modules", ".git"],
    "items": {
      "type": "string"
    },
    "description": "Paths to exclude from processing"
  },
  "myExtension.rules": {
    "type": "array",
    "default": [],
    "items": {
      "type": "object",
      "properties": {
        "pattern": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      }
    },
    "description": "Custom rules"
  }
}
```

### Object Settings

```json
{
  "myExtension.colors": {
    "type": "object",
    "default": {
      "error": "#ff0000",
      "warning": "#ffaa00",
      "info": "#0088ff"
    },
    "properties": {
      "error": {
        "type": "string",
        "description": "Color for errors"
      },
      "warning": {
        "type": "string",
        "description": "Color for warnings"
      },
      "info": {
        "type": "string",
        "description": "Color for info"
      }
    },
    "description": "Custom colors"
  }
}
```

## Reading Configuration

### Basic Configuration Reading

```typescript
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    // Get extension configuration
    const config = vscode.workspace.getConfiguration('myExtension');

    // Read simple values
    const isEnabled = config.get<boolean>('enable', true);
    const maxItems = config.get<number>('maxItems', 10);
    const format = config.get<string>('outputFormat', 'json');

    console.log(`Enabled: ${isEnabled}`);
    console.log(`Max items: ${maxItems}`);
    console.log(`Format: ${format}`);
}
```

### Reading with Default Fallback

```typescript
// If setting doesn't exist, use fallback
const timeout = config.get<number>('timeout', 5000); // Returns 5000 if not set

// Get without fallback (returns undefined if not set)
const customValue = config.get<string>('customValue');
if (customValue) {
    console.log(`Custom: ${customValue}`);
}
```

### Reading Complex Types

```typescript
// Read array
const excludePaths = config.get<string[]>('excludePaths', []);
excludePaths.forEach(path => console.log(path));

// Read object
interface ColorConfig {
    error: string;
    warning: string;
    info: string;
}

const colors = config.get<ColorConfig>('colors');
if (colors) {
    console.log(`Error color: ${colors.error}`);
}
```

### Reading from Specific Scope

```typescript
// User settings (global)
const userConfig = vscode.workspace.getConfiguration(
    'myExtension',
    null
);

// Workspace settings
const workspaceConfig = vscode.workspace.getConfiguration(
    'myExtension',
    vscode.ConfigurationTarget.Workspace
);

// Get resource-specific config (respects workspace folders)
const editor = vscode.window.activeTextEditor;
if (editor) {
    const resourceConfig = vscode.workspace.getConfiguration(
        'myExtension',
        editor.document.uri
    );
}
```

## Updating Configuration

### Basic Update

```typescript
const config = vscode.workspace.getConfiguration('myExtension');

// Update at Global level
await config.update('enable', false, vscode.ConfigurationTarget.Global);

// Update at Workspace level
await config.update('maxItems', 20, vscode.ConfigurationTarget.Workspace);

// Update at WorkspaceFolder level
await config.update('outputFormat', 'xml', vscode.ConfigurationTarget.WorkspaceFolder);
```

### Update with User Interaction

```typescript
const updateSettingCommand = vscode.commands.registerCommand(
    'myExtension.updateMaxItems',
    async () => {
        const current = vscode.workspace
            .getConfiguration('myExtension')
            .get<number>('maxItems', 10);

        const input = await vscode.window.showInputBox({
            prompt: 'Enter maximum items',
            value: current.toString(),
            validateInput: (value) => {
                const num = parseInt(value);
                if (isNaN(num) || num < 1 || num > 100) {
                    return 'Enter a number between 1 and 100';
                }
                return null;
            }
        });

        if (!input) return;

        const config = vscode.workspace.getConfiguration('myExtension');
        await config.update('maxItems', parseInt(input), vscode.ConfigurationTarget.Global);

        vscode.window.showInformationMessage(`Max items set to ${input}`);
    }
);
```

### Batch Updates

```typescript
async function applyPreset(preset: 'minimal' | 'full') {
    const config = vscode.workspace.getConfiguration('myExtension');

    if (preset === 'minimal') {
        await config.update('enable', true, vscode.ConfigurationTarget.Global);
        await config.update('maxItems', 5, vscode.ConfigurationTarget.Global);
        await config.update('showWarnings', false, vscode.ConfigurationTarget.Global);
    } else {
        await config.update('enable', true, vscode.ConfigurationTarget.Global);
        await config.update('maxItems', 50, vscode.ConfigurationTarget.Global);
        await config.update('showWarnings', true, vscode.ConfigurationTarget.Global);
    }

    vscode.window.showInformationMessage(`Applied ${preset} preset`);
}
```

## Listening to Configuration Changes

### Basic Change Listener

```typescript
export function activate(context: vscode.ExtensionContext) {
    // Listen to configuration changes
    const configListener = vscode.workspace.onDidChangeConfiguration(e => {
        // Check if our extension's config changed
        if (e.affectsConfiguration('myExtension')) {
            console.log('My extension configuration changed');
            reloadConfiguration();
        }

        // Check specific setting
        if (e.affectsConfiguration('myExtension.enable')) {
            const isEnabled = vscode.workspace
                .getConfiguration('myExtension')
                .get<boolean>('enable', true);

            console.log(`Extension ${isEnabled ? 'enabled' : 'disabled'}`);
        }
    });

    context.subscriptions.push(configListener);
}

function reloadConfiguration() {
    const config = vscode.workspace.getConfiguration('myExtension');
    // Re-read and apply all settings
}
```

### Resource-Specific Changes

```typescript
vscode.workspace.onDidChangeConfiguration(e => {
    const editor = vscode.window.activeTextEditor;
    if (!editor) return;

    // Check if config changed for specific resource
    if (e.affectsConfiguration('myExtension', editor.document.uri)) {
        console.log('Configuration changed for current file');
    }
});
```

### Reactive Configuration Pattern

```typescript
class ConfigManager {
    private config: vscode.WorkspaceConfiguration;
    private disposables: vscode.Disposable[] = [];

    constructor() {
        this.config = vscode.workspace.getConfiguration('myExtension');

        // Watch for changes
        this.disposables.push(
            vscode.workspace.onDidChangeConfiguration(e => {
                if (e.affectsConfiguration('myExtension')) {
                    this.reload();
                }
            })
        );
    }

    reload() {
        this.config = vscode.workspace.getConfiguration('myExtension');
        this.applySettings();
    }

    applySettings() {
        const isEnabled = this.config.get<boolean>('enable', true);
        const maxItems = this.config.get<number>('maxItems', 10);

        // Apply settings to your extension
        console.log(`Settings applied: enabled=${isEnabled}, max=${maxItems}`);
    }

    get<T>(key: string, defaultValue: T): T {
        return this.config.get<T>(key, defaultValue);
    }

    dispose() {
        this.disposables.forEach(d => d.dispose());
    }
}

// Usage
export function activate(context: vscode.ExtensionContext) {
    const configManager = new ConfigManager();
    context.subscriptions.push(configManager);
}
```

## Advanced Configuration Features

### Markdown Descriptions

```json
{
  "myExtension.formatOnSave": {
    "type": "boolean",
    "default": false,
    "markdownDescription": "Format document on save.\n\n**Note:** Requires `editor.formatOnSave` to be enabled."
  }
}
```

### Deprecation Notices

```json
{
  "myExtension.oldSetting": {
    "type": "string",
    "deprecationMessage": "This setting is deprecated. Use `myExtension.newSetting` instead.",
    "markdownDeprecationMessage": "**Deprecated:** Use `#myExtension.newSetting#` instead."
  }
}
```

### Scope Control

```json
{
  "myExtension.apiKey": {
    "type": "string",
    "scope": "machine",
    "description": "API key (not synced across machines)"
  },
  "myExtension.theme": {
    "type": "string",
    "scope": "window",
    "description": "Theme preference (per window)"
  },
  "myExtension.formatting": {
    "type": "object",
    "scope": "resource",
    "description": "Formatting rules (per file/folder)"
  }
}
```

**Scope types:**
- **application**: Applies to all VS Code instances
- **machine**: Machine-specific (not synced)
- **window**: Per-window setting
- **resource**: Per-file/folder setting
- **language-overridable**: Can be overridden per language

### Language-Specific Settings

Users can override settings per language:

```json
{
  "[javascript]": {
    "myExtension.maxItems": 20
  },
  "[python]": {
    "myExtension.maxItems": 30
  }
}
```

Access in code:

```typescript
const editor = vscode.window.activeTextEditor;
if (editor) {
    const languageId = editor.document.languageId;
    const config = vscode.workspace.getConfiguration('myExtension', editor.document.uri);
    const maxItems = config.get<number>('maxItems', 10);

    console.log(`Max items for ${languageId}: ${maxItems}`);
}
```

### Pattern Properties (Dynamic Keys)

```json
{
  "myExtension.servers": {
    "type": "object",
    "patternProperties": {
      ".*": {
        "type": "object",
        "properties": {
          "url": { "type": "string" },
          "timeout": { "type": "number" }
        }
      }
    },
    "default": {},
    "description": "Server configurations"
  }
}
```

Users can add dynamic keys:

```json
{
  "myExtension.servers": {
    "production": {
      "url": "https://prod.example.com",
      "timeout": 5000
    },
    "staging": {
      "url": "https://staging.example.com",
      "timeout": 3000
    }
  }
}
```

### Order and Categories

```json
{
  "contributes": {
    "configuration": [
      {
        "title": "General",
        "order": 1,
        "properties": {
          "myExtension.enable": {
            "order": 1,
            "type": "boolean",
            "default": true
          }
        }
      },
      {
        "title": "Advanced",
        "order": 2,
        "properties": {
          "myExtension.debugMode": {
            "type": "boolean",
            "default": false
          }
        }
      }
    ]
  }
}
```

## Validation Patterns

### Custom Validation in Code

```typescript
async function validateApiKey(apiKey: string): Promise<boolean> {
    // Validate format
    if (!/^[A-Za-z0-9]{32}$/.test(apiKey)) {
        vscode.window.showErrorMessage('Invalid API key format');
        return false;
    }

    // Validate with server
    try {
        const response = await fetch('https://api.example.com/validate', {
            headers: { 'Authorization': `Bearer ${apiKey}` }
        });
        return response.ok;
    } catch (error) {
        vscode.window.showErrorMessage('Failed to validate API key');
        return false;
    }
}

const setApiKeyCommand = vscode.commands.registerCommand(
    'myExtension.setApiKey',
    async () => {
        const apiKey = await vscode.window.showInputBox({
            prompt: 'Enter API key',
            password: true,
            validateInput: async (value) => {
                if (!value) return 'API key is required';
                if (!/^[A-Za-z0-9]{32}$/.test(value)) {
                    return 'API key must be 32 alphanumeric characters';
                }
                return null;
            }
        });

        if (!apiKey) return;

        if (await validateApiKey(apiKey)) {
            const config = vscode.workspace.getConfiguration('myExtension');
            await config.update('apiKey', apiKey, vscode.ConfigurationTarget.Global);
            vscode.window.showInformationMessage('API key set successfully');
        }
    }
);
```

### Schema Validation

```json
{
  "myExtension.server": {
    "type": "object",
    "properties": {
      "host": {
        "type": "string",
        "pattern": "^[a-z0-9.-]+$"
      },
      "port": {
        "type": "integer",
        "minimum": 1,
        "maximum": 65535
      }
    },
    "required": ["host", "port"],
    "default": {
      "host": "localhost",
      "port": 8080
    }
  }
}
```

## Complete Example: Project Manager

```typescript
import * as vscode from 'vscode';

interface ProjectConfig {
    name: string;
    path: string;
    tags: string[];
}

class ProjectManager {
    private config: vscode.WorkspaceConfiguration;
    private disposables: vscode.Disposable[] = [];

    constructor(private context: vscode.ExtensionContext) {
        this.config = vscode.workspace.getConfiguration('projectManager');
        this.registerCommands();
        this.watchConfiguration();
    }

    private registerCommands() {
        // Command: Add project
        this.disposables.push(
            vscode.commands.registerCommand('projectManager.addProject', () => {
                this.addProject();
            })
        );

        // Command: List projects
        this.disposables.push(
            vscode.commands.registerCommand('projectManager.listProjects', () => {
                this.listProjects();
            })
        );

        // Command: Configure settings
        this.disposables.push(
            vscode.commands.registerCommand('projectManager.configure', () => {
                this.showConfiguration();
            })
        );
    }

    private watchConfiguration() {
        this.disposables.push(
            vscode.workspace.onDidChangeConfiguration(e => {
                if (e.affectsConfiguration('projectManager')) {
                    this.config = vscode.workspace.getConfiguration('projectManager');
                    this.applySettings();
                }
            })
        );
    }

    private applySettings() {
        const autoScan = this.config.get<boolean>('autoScan', false);
        const maxProjects = this.config.get<number>('maxProjects', 50);

        console.log(`Auto scan: ${autoScan}, Max projects: ${maxProjects}`);

        if (autoScan) {
            this.scanWorkspace();
        }
    }

    private async addProject() {
        const name = await vscode.window.showInputBox({
            prompt: 'Project name',
            validateInput: (value) => value ? null : 'Name is required'
        });

        if (!name) return;

        const folderUri = await vscode.window.showOpenDialog({
            canSelectFolders: true,
            canSelectFiles: false,
            canSelectMany: false,
            openLabel: 'Select Project Folder'
        });

        if (!folderUri || folderUri.length === 0) return;

        const projects = this.config.get<ProjectConfig[]>('projects', []);
        const maxProjects = this.config.get<number>('maxProjects', 50);

        if (projects.length >= maxProjects) {
            vscode.window.showErrorMessage(`Cannot add more than ${maxProjects} projects`);
            return;
        }

        projects.push({
            name,
            path: folderUri[0].fsPath,
            tags: []
        });

        await this.config.update('projects', projects, vscode.ConfigurationTarget.Global);
        vscode.window.showInformationMessage(`Added project: ${name}`);
    }

    private async listProjects() {
        const projects = this.config.get<ProjectConfig[]>('projects', []);

        if (projects.length === 0) {
            vscode.window.showInformationMessage('No projects configured');
            return;
        }

        const items = projects.map(p => ({
            label: p.name,
            description: p.path,
            detail: p.tags.join(', ')
        }));

        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select a project'
        });

        if (selected) {
            const uri = vscode.Uri.file(selected.description!);
            await vscode.commands.executeCommand('vscode.openFolder', uri);
        }
    }

    private async showConfiguration() {
        await vscode.commands.executeCommand(
            'workbench.action.openSettings',
            'projectManager'
        );
    }

    private scanWorkspace() {
        // Implementation for workspace scanning
        console.log('Scanning workspace for projects...');
    }

    dispose() {
        this.disposables.forEach(d => d.dispose());
    }
}

export function activate(context: vscode.ExtensionContext) {
    const manager = new ProjectManager(context);
    context.subscriptions.push(manager);
}
```

**package.json:**

```json
{
  "contributes": {
    "configuration": {
      "title": "Project Manager",
      "properties": {
        "projectManager.projects": {
          "type": "array",
          "default": [],
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "path": { "type": "string" },
              "tags": {
                "type": "array",
                "items": { "type": "string" }
              }
            }
          },
          "description": "List of saved projects"
        },
        "projectManager.autoScan": {
          "type": "boolean",
          "default": false,
          "description": "Automatically scan workspace for projects"
        },
        "projectManager.maxProjects": {
          "type": "number",
          "default": 50,
          "minimum": 1,
          "maximum": 500,
          "description": "Maximum number of projects"
        },
        "projectManager.sortBy": {
          "type": "string",
          "default": "name",
          "enum": ["name", "path", "recent"],
          "enumDescriptions": [
            "Sort alphabetically by name",
            "Sort by file path",
            "Sort by recently used"
          ],
          "description": "How to sort projects"
        }
      }
    },
    "commands": [
      {
        "command": "projectManager.addProject",
        "title": "Add Project",
        "category": "Project Manager"
      },
      {
        "command": "projectManager.listProjects",
        "title": "List Projects",
        "category": "Project Manager"
      },
      {
        "command": "projectManager.configure",
        "title": "Configure",
        "category": "Project Manager"
      }
    ]
  }
}
```

## Best Practices

### 1. Use Descriptive Names

```json
// ✅ Good
"myExtension.autoSaveEnabled": { ... }
"myExtension.maxRetryAttempts": { ... }

// ❌ Bad
"myExtension.enabled": { ... }
"myExtension.max": { ... }
```

### 2. Provide Good Defaults

```json
// ✅ Good: Sensible defaults
{
  "myExtension.timeout": {
    "type": "number",
    "default": 5000
  }
}

// ❌ Bad: No default
{
  "myExtension.timeout": {
    "type": "number"
  }
}
```

### 3. Use Markdown Descriptions

```json
{
  "myExtension.feature": {
    "markdownDescription": "Enable **experimental** feature.\n\n⚠️ Warning: This may cause instability."
  }
}
```

### 4. Choose Appropriate Scope

```json
// ✅ Good: API keys are machine-specific
{
  "myExtension.apiKey": {
    "scope": "machine"
  }
}

// ✅ Good: Formatting is per-resource
{
  "myExtension.formatRules": {
    "scope": "resource"
  }
}
```

### 5. Handle Configuration Errors Gracefully

```typescript
function getConfig<T>(key: string, defaultValue: T): T {
    try {
        const config = vscode.workspace.getConfiguration('myExtension');
        return config.get<T>(key, defaultValue);
    } catch (error) {
        console.error(`Error reading config ${key}:`, error);
        return defaultValue;
    }
}
```

## Summary

You've learned:

- ✅ How to declare configuration schemas
- ✅ All configuration types (boolean, string, number, array, object)
- ✅ Reading and updating configuration
- ✅ Listening to configuration changes
- ✅ Advanced features (markdown, deprecation, scopes)
- ✅ Validation patterns
- ✅ Best practices for configuration

## Exercise

Create a "Code Formatter" extension with configuration for:
1. Enable/disable formatting
2. Indent size (with min/max validation)
3. Quote style (single/double/auto)
4. Line length limit
5. Custom formatting rules (array of objects)
6. Language-specific overrides

Requirements:
- All settings visible in Settings UI
- Change listener that reloads settings
- Command to apply preset configurations
- Proper validation and defaults

## Next Steps

Continue to [2.3 Menus and Context Menus](./2.3-menus-and-context-menus.md) to learn how to add your commands to VS Code's UI.

## Additional Resources

- [Configuration API](https://code.visualstudio.com/api/references/vscode-api#workspace.getConfiguration)
- [Configuration Contribution](https://code.visualstudio.com/api/references/contribution-points#contributes.configuration)
- [Settings Sync](https://code.visualstudio.com/docs/editor/settings-sync)
