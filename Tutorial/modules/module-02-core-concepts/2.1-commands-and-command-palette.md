# 2.1 Commands and Command Palette

## Introduction

Commands are the fundamental building blocks of VS Code extensions. They're actions that users can invoke through the Command Palette, keyboard shortcuts, menus, or programmatically. This lesson covers everything you need to know about creating and managing commands.

## What Are Commands?

Commands in VS Code are:
- **Named actions** identified by unique strings (e.g., `extension.myCommand`)
- **Registered functions** that execute when invoked
- **Discoverable** through Command Palette (Ctrl+Shift+P / Cmd+Shift+P)
- **Bindable** to keyboard shortcuts and UI elements

## Command Registration Basics

### Simple Command Registration

```typescript
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    // Register a simple command
    const disposable = vscode.commands.registerCommand(
        'myExtension.helloWorld',
        () => {
            vscode.window.showInformationMessage('Hello from My Extension!');
        }
    );

    // Add to subscriptions for cleanup
    context.subscriptions.push(disposable);
}
```

**Key Points:**
- `registerCommand` returns a `Disposable` for cleanup
- Always add disposables to `context.subscriptions`
- Command IDs should be prefixed with extension name

### Command with Parameters

```typescript
const greetCommand = vscode.commands.registerCommand(
    'myExtension.greet',
    (name: string, greeting: string = 'Hello') => {
        vscode.window.showInformationMessage(`${greeting}, ${name}!`);
    }
);

context.subscriptions.push(greetCommand);
```

**Usage:**
```typescript
// Call programmatically
vscode.commands.executeCommand('myExtension.greet', 'Alice', 'Hi');
```

### Command with Return Value

```typescript
const calculateCommand = vscode.commands.registerCommand(
    'myExtension.calculate',
    (a: number, b: number): number => {
        return a + b;
    }
);

context.subscriptions.push(calculateCommand);

// Using the return value
const result = await vscode.commands.executeCommand(
    'myExtension.calculate',
    10,
    20
);
console.log(result); // 30
```

## Declaring Commands in package.json

To make commands visible in Command Palette, declare them in `package.json`:

```json
{
  "contributes": {
    "commands": [
      {
        "command": "myExtension.helloWorld",
        "title": "Hello World",
        "category": "My Extension"
      },
      {
        "command": "myExtension.greet",
        "title": "Greet User",
        "category": "My Extension",
        "icon": "$(person)"
      },
      {
        "command": "myExtension.calculate",
        "title": "Calculate Sum",
        "category": "My Extension",
        "enablement": "editorTextFocus"
      }
    ]
  }
}
```

**Properties:**
- **command**: Unique identifier (must match registration)
- **title**: Display name in Command Palette
- **category**: Groups related commands
- **icon**: Codicon or file path for toolbar/menus
- **enablement**: When clause for conditional availability

## Command Palette Integration

### Making Commands Searchable

Commands declared in `package.json` automatically appear in Command Palette:

```typescript
// package.json
{
  "contributes": {
    "commands": [
      {
        "command": "myExtension.openSettings",
        "title": "Open Settings",
        "category": "My Extension"
      }
    ]
  }
}
```

Users can find it by typing: "My Extension: Open Settings"

### Conditional Command Visibility

Hide commands from palette based on context:

```json
{
  "contributes": {
    "commands": [
      {
        "command": "myExtension.runTest",
        "title": "Run Test"
      }
    ],
    "menus": {
      "commandPalette": [
        {
          "command": "myExtension.runTest",
          "when": "resourceExtname == .test.js"
        }
      ]
    }
  }
}
```

**Common when clauses:**
- `editorTextFocus`: Editor has focus
- `editorHasSelection`: Text is selected
- `resourceExtname == .js`: File extension check
- `workspaceFolderCount > 0`: Workspace is open

## Working with Editor Context

### Getting Active Editor

```typescript
const editCommand = vscode.commands.registerCommand(
    'myExtension.insertText',
    () => {
        const editor = vscode.window.activeTextEditor;

        if (!editor) {
            vscode.window.showErrorMessage('No active editor!');
            return;
        }

        editor.edit(editBuilder => {
            editBuilder.insert(editor.selection.active, 'Hello!');
        });
    }
);
```

### Working with Selections

```typescript
const uppercaseCommand = vscode.commands.registerCommand(
    'myExtension.uppercaseSelection',
    () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) return;

        const selection = editor.selection;
        const text = editor.document.getText(selection);

        editor.edit(editBuilder => {
            editBuilder.replace(selection, text.toUpperCase());
        });
    }
);
```

### Multi-Cursor Support

```typescript
const reverseCommand = vscode.commands.registerCommand(
    'myExtension.reverseSelections',
    () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) return;

        editor.edit(editBuilder => {
            // Process all selections (supports multi-cursor)
            editor.selections.forEach(selection => {
                const text = editor.document.getText(selection);
                const reversed = text.split('').reverse().join('');
                editBuilder.replace(selection, reversed);
            });
        });
    }
);
```

## Built-in Commands

VS Code provides many built-in commands you can use:

### Common Built-in Commands

```typescript
// Open settings
await vscode.commands.executeCommand('workbench.action.openSettings');

// Save current file
await vscode.commands.executeCommand('workbench.action.files.save');

// Format document
await vscode.commands.executeCommand('editor.action.formatDocument');

// Toggle sidebar
await vscode.commands.executeCommand('workbench.action.toggleSidebarVisibility');

// Show hover
await vscode.commands.executeCommand('editor.action.showHover');

// Go to definition
await vscode.commands.executeCommand('editor.action.revealDefinition');
```

### File and Editor Operations

```typescript
// Open a file
const uri = vscode.Uri.file('/path/to/file.txt');
await vscode.commands.executeCommand('vscode.open', uri);

// Open file to the side
await vscode.commands.executeCommand('vscode.open', uri, vscode.ViewColumn.Beside);

// Close active editor
await vscode.commands.executeCommand('workbench.action.closeActiveEditor');

// Split editor
await vscode.commands.executeCommand('workbench.action.splitEditor');
```

### Getting Command List

```typescript
const allCommands = await vscode.commands.getCommands();
console.log(allCommands.filter(cmd => cmd.startsWith('editor.')));
```

## Command URIs

Commands can be embedded in markdown, webviews, and hovers as URIs:

### Basic Command URI

```typescript
const uri = vscode.Uri.parse(`command:myExtension.helloWorld`);
```

### Command URI with Arguments

```typescript
const args = encodeURIComponent(JSON.stringify(['Alice', 'Hi']));
const uri = vscode.Uri.parse(`command:myExtension.greet?${args}`);
```

### Using in Markdown

```typescript
const markdown = new vscode.MarkdownString(
    '[Click to greet](command:myExtension.greet?["Bob","Hello"])'
);
markdown.isTrusted = true; // Required for command links
```

### Using in Webview

```html
<a href="command:myExtension.openSettings">Open Settings</a>
```

## Advanced Command Patterns

### Command with Confirmation

```typescript
const deleteCommand = vscode.commands.registerCommand(
    'myExtension.deleteFile',
    async (fileUri: vscode.Uri) => {
        const fileName = path.basename(fileUri.fsPath);

        const answer = await vscode.window.showWarningMessage(
            `Delete ${fileName}?`,
            { modal: true },
            'Yes',
            'No'
        );

        if (answer === 'Yes') {
            await vscode.workspace.fs.delete(fileUri);
            vscode.window.showInformationMessage(`Deleted ${fileName}`);
        }
    }
);
```

### Command with Progress

```typescript
const processCommand = vscode.commands.registerCommand(
    'myExtension.processFiles',
    async () => {
        await vscode.window.withProgress(
            {
                location: vscode.ProgressLocation.Notification,
                title: 'Processing files',
                cancellable: true
            },
            async (progress, token) => {
                token.onCancellationRequested(() => {
                    console.log('User cancelled');
                });

                for (let i = 0; i < 100; i++) {
                    if (token.isCancellationRequested) {
                        break;
                    }

                    progress.report({
                        increment: 1,
                        message: `Processing file ${i + 1}/100`
                    });

                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }
        );
    }
);
```

### Command with Input

```typescript
const createFileCommand = vscode.commands.registerCommand(
    'myExtension.createFile',
    async () => {
        const fileName = await vscode.window.showInputBox({
            prompt: 'Enter file name',
            placeHolder: 'example.txt',
            validateInput: (value) => {
                if (!value) {
                    return 'File name is required';
                }
                if (!/^[\w-]+\.[\w]+$/.test(value)) {
                    return 'Invalid file name format';
                }
                return null;
            }
        });

        if (!fileName) return;

        // Create file logic here
        vscode.window.showInformationMessage(`Creating ${fileName}`);
    }
);
```

### Command with Quick Pick

```typescript
interface ActionItem extends vscode.QuickPickItem {
    action: () => void;
}

const menuCommand = vscode.commands.registerCommand(
    'myExtension.showMenu',
    async () => {
        const actions: ActionItem[] = [
            {
                label: '$(file-add) Create File',
                description: 'Create a new file',
                action: () => vscode.commands.executeCommand('myExtension.createFile')
            },
            {
                label: '$(folder-opened) Open Folder',
                description: 'Open a folder',
                action: () => vscode.commands.executeCommand('vscode.openFolder')
            },
            {
                label: '$(gear) Settings',
                description: 'Open settings',
                action: () => vscode.commands.executeCommand('workbench.action.openSettings')
            }
        ];

        const selected = await vscode.window.showQuickPick(actions, {
            placeHolder: 'Select an action'
        });

        if (selected) {
            selected.action();
        }
    }
);
```

## Keyboard Shortcuts (Keybindings)

### Defining Keybindings

In `package.json`:

```json
{
  "contributes": {
    "keybindings": [
      {
        "command": "myExtension.helloWorld",
        "key": "ctrl+shift+h",
        "mac": "cmd+shift+h",
        "when": "editorTextFocus"
      },
      {
        "command": "myExtension.runTest",
        "key": "ctrl+shift+t",
        "mac": "cmd+shift+t",
        "when": "resourceExtname == .test.js"
      }
    ]
  }
}
```

**Platform-specific keys:**
- **key**: Windows/Linux
- **mac**: macOS
- **linux**: Linux-only override
- **win**: Windows-only override

### Common Key Combinations

```json
{
  "keybindings": [
    {
      "command": "myExtension.action1",
      "key": "ctrl+k ctrl+s"
    },
    {
      "command": "myExtension.action2",
      "key": "ctrl+alt+shift+p"
    }
  ]
}
```

## Error Handling

### Proper Error Messages

```typescript
const riskyCommand = vscode.commands.registerCommand(
    'myExtension.riskyOperation',
    async () => {
        try {
            // Risky operation
            const result = await someAsyncOperation();
            vscode.window.showInformationMessage('Operation succeeded!');
        } catch (error) {
            vscode.window.showErrorMessage(
                `Operation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
            );
            console.error('Detailed error:', error);
        }
    }
);
```

### Validation Before Execution

```typescript
const saveCommand = vscode.commands.registerCommand(
    'myExtension.saveData',
    async () => {
        const editor = vscode.window.activeTextEditor;

        if (!editor) {
            vscode.window.showErrorMessage('No active editor');
            return;
        }

        if (editor.document.isDirty) {
            vscode.window.showWarningMessage('Document has unsaved changes');
            return;
        }

        // Proceed with save
    }
);
```

## Best Practices

### 1. Command Naming

```typescript
// ✅ Good: Namespaced, descriptive
'myExtension.formatDocument'
'myExtension.git.commit'

// ❌ Bad: Generic, collision risk
'format'
'commit'
```

### 2. Always Dispose Commands

```typescript
export function activate(context: vscode.ExtensionContext) {
    // ✅ Good: Added to subscriptions
    context.subscriptions.push(
        vscode.commands.registerCommand('myExtension.cmd', () => {})
    );

    // ❌ Bad: Not disposed
    vscode.commands.registerCommand('myExtension.cmd2', () => {});
}
```

### 3. Validate Context

```typescript
// ✅ Good: Check preconditions
vscode.commands.registerCommand('myExtension.format', () => {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
    }
    // Proceed...
});

// ❌ Bad: Assume context
vscode.commands.registerCommand('myExtension.format', () => {
    const editor = vscode.window.activeTextEditor;
    editor.edit(...); // Might crash!
});
```

### 4. Use Async/Await

```typescript
// ✅ Good: Proper async handling
vscode.commands.registerCommand('myExtension.load', async () => {
    const data = await loadData();
    await processData(data);
});

// ❌ Bad: Unhandled promises
vscode.commands.registerCommand('myExtension.load', () => {
    loadData().then(processData); // Errors not caught
});
```

### 5. Provide User Feedback

```typescript
// ✅ Good: Inform user of progress
vscode.commands.registerCommand('myExtension.process', async () => {
    await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Processing...'
    }, async (progress) => {
        await heavyOperation();
    });
});

// ❌ Bad: No feedback
vscode.commands.registerCommand('myExtension.process', async () => {
    await heavyOperation(); // User doesn't know what's happening
});
```

## Complete Example: Document Analyzer

```typescript
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    // Command 1: Analyze current document
    const analyzeCommand = vscode.commands.registerCommand(
        'docAnalyzer.analyze',
        async () => {
            const editor = vscode.window.activeTextEditor;

            if (!editor) {
                vscode.window.showErrorMessage('No active editor');
                return;
            }

            await vscode.window.withProgress(
                {
                    location: vscode.ProgressLocation.Notification,
                    title: 'Analyzing document',
                    cancellable: false
                },
                async () => {
                    const document = editor.document;
                    const text = document.getText();

                    const stats = {
                        lines: document.lineCount,
                        chars: text.length,
                        words: text.split(/\s+/).filter(w => w).length
                    };

                    const message = `Lines: ${stats.lines}, Words: ${stats.words}, Chars: ${stats.chars}`;
                    const action = await vscode.window.showInformationMessage(
                        message,
                        'Copy Stats'
                    );

                    if (action === 'Copy Stats') {
                        await vscode.env.clipboard.writeText(message);
                    }
                }
            );
        }
    );

    // Command 2: Find long lines
    const findLongLinesCommand = vscode.commands.registerCommand(
        'docAnalyzer.findLongLines',
        async () => {
            const editor = vscode.window.activeTextEditor;
            if (!editor) return;

            const maxLength = await vscode.window.showInputBox({
                prompt: 'Maximum line length',
                value: '80',
                validateInput: (value) => {
                    const num = parseInt(value);
                    return isNaN(num) || num < 1 ? 'Enter a valid number' : null;
                }
            });

            if (!maxLength) return;
            const max = parseInt(maxLength);

            const longLines: number[] = [];
            const document = editor.document;

            for (let i = 0; i < document.lineCount; i++) {
                const line = document.lineAt(i);
                if (line.text.length > max) {
                    longLines.push(i + 1);
                }
            }

            if (longLines.length === 0) {
                vscode.window.showInformationMessage('No long lines found!');
            } else {
                vscode.window.showWarningMessage(
                    `Found ${longLines.length} long lines: ${longLines.slice(0, 5).join(', ')}${
                        longLines.length > 5 ? '...' : ''
                    }`
                );
            }
        }
    );

    context.subscriptions.push(analyzeCommand, findLongLinesCommand);
}
```

**package.json:**

```json
{
  "contributes": {
    "commands": [
      {
        "command": "docAnalyzer.analyze",
        "title": "Analyze Document",
        "category": "Doc Analyzer",
        "icon": "$(graph)"
      },
      {
        "command": "docAnalyzer.findLongLines",
        "title": "Find Long Lines",
        "category": "Doc Analyzer"
      }
    ],
    "keybindings": [
      {
        "command": "docAnalyzer.analyze",
        "key": "ctrl+shift+a",
        "mac": "cmd+shift+a",
        "when": "editorTextFocus"
      }
    ]
  }
}
```

## Summary

You've learned:

- ✅ How to register and declare commands
- ✅ Command parameters and return values
- ✅ Command Palette integration
- ✅ Working with editor context
- ✅ Using built-in commands
- ✅ Command URIs in markdown/webviews
- ✅ Advanced patterns (confirmation, progress, input)
- ✅ Keyboard shortcut configuration
- ✅ Error handling and best practices

## Exercise

Create a "Text Transformer" extension with commands to:
1. Convert selection to uppercase/lowercase
2. Reverse selected text
3. Sort selected lines alphabetically
4. Remove duplicate lines
5. Count occurrences of a search term

Requirements:
- All commands in Command Palette
- Keyboard shortcuts for first 3 commands
- Proper error handling
- User feedback with progress

## Next Steps

Continue to [2.2 Configuration and Settings](./2.2-configuration-and-settings.md) to learn how to add settings to your extension.

## Additional Resources

- [Commands API Reference](https://code.visualstudio.com/api/references/vscode-api#commands)
- [Built-in Commands](https://code.visualstudio.com/api/references/commands)
- [Keybinding Rules](https://code.visualstudio.com/api/references/keybinding-rules)
- [When Clause Contexts](https://code.visualstudio.com/api/references/when-clause-contexts)
